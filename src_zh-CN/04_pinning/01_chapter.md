# 固定（Pinning）

为了轮询 future，future 首先要用特殊类型 `Pin<T>` 来固定。如果你读了前面《执行 `Future` 与任务小节中关于 `Future` 退出的解释，你会从 `Future::poll` 方法的定义中认出 `Pin`。但这意味什么？我们为什么需要它？

## 为什么需要固定

固定保证对象永不移动。为了理解这为什么必须，我们回忆一下 `async`/`.await` 怎么工作吧。考虑以下代码：

```rust,edition2018,ignore
let fut_one = ...;
let fut_two = ...;
async move {
    fut_one.await;
    fut_two.await;
}
```

这段代码实际上创建了一个实现了 `Future` 特质的匿名类型，提供了 `poll` 方法，如下：

```rust,no_run
// The `Future` type generated by our `async { ... }` block
struct AsyncFuture {
    fut_one: FutOne,
    fut_two: FutTwo,
    state: State,
}

// List of states our `async` block can be in
enum State {
    AwaitingFutOne,
    AwaitingFutTwo,
    Done,
}

impl Future for AsyncFuture {
    fn poll(self: Pin<&mut Self>, cx: &mut Context<'_>) -> Poll<()> {
        loop {
            match self.state {
                State::AwaitingFutOne => match self.fut_one.poll(..) {
                    Poll::Ready(()) => self.state = State::AwaitingFutTwo,
                    Poll::Pending => return Poll::Pending,
                }
                State::AwaitingFutTwo => match self.fut_two.poll(..) {
                    Poll::Ready(()) => self.state = State::Done,
                    Poll::Pending => return Poll::Pending,
                }
                State::Done => return Poll::Ready(()),
            }
        }
    }
}
```

当 `poll` 第一次调用时，它会轮询 `fut_one`。如果 `fut_one` 不能完成，那么 `AsyncFuture::poll` 就会返回。调用 `poll` 的 Future 会从上次中断的地方继续。这个过程会持续到 future 成功完成。

然而，如果我们在 `async` 块中用了引用呢？例如：

```rust,no_run
async {
    let mut x = [0; 128];
    let read_into_buf_fut = read_into_buf(&mut x);
    read_into_buf_fut.await;
    println!("{:?}", x);
}
```

这会编译成什么结构呢？

```rust
struct ReadIntoBuf<'a> {
    buf: &'a mut [u8], // points to `x` below
}

struct AsyncFuture {
    x: [u8; 128],
    read_into_buf_fut: ReadIntoBuf<'what_lifetime?>,
}
```

这里，`ReadIhtoBuf` future 持有了一个指向其他字段 `x` 的引用。然而，如果 `AsyncFuture` 被移动了，`x` 的位置（location）也会被移走，使得存储在 `read_into_buf_fut.buf` 的指针失效。

固定 future 到内存特定位置则阻止了这种问题，让创建指向 `async` 块的引用变得安全。

## 如何固定？

`Pin` 类型包装了指针类型，保证了指针指向的值不会被移走。例如，`Pin<&mut T>`，`Pin<&T>` 和 `Pin<Box<T>>` 全都保证了 `T` 不会被移走。

多数类型被移走也不会有问题。这些类型实现了 `Unpin` 特质。指向 `Unpin` 类型的指针能够自由地放进 `Pin`，或取走。例如，`u8` 是 `Unpin` 的，所以 `Pin<&mut T>` 的行为就像普通的 `&mut T`。

一些函数需要他们协作的 future 是 `Unpin` 的。为了让这些函数使用不是 `Unpin` 的 `Future` 或 `Stream`，你首先需要这个值固定，要么用 `Box::pin`（创建 `Pin<Box<T>>`）要么使用 `pin_utils::pin_mut!`（创建 `Pin<&mut T>`）。`Pin<Box<Fut>>` 和 `Pin<&mut Fut>` 都能用作 future，并且都实现了 `Unpin`。

例如：

```rust,no_run
use pin_utils::pin_mut; // `pin_utils` is a handy crate available on crates.io

// A function which takes a `Future` that implements `Unpin`.
fn execute_unpin_future(x: impl Future<Output = ()> + Unpin) { ... }

let fut = async { ... };
execute_unpin_future(fut); // Error: `fut` does not implement `Unpin` trait

// Pinning with `Box`:
let fut = async { ... };
let fut = Box::pin(fut);
execute_unpin_future(fut); // OK

// Pinning with `pin_mut!`:
let fut = async { ... };
pin_mut!(fut);
execute_unpin_future(fut); // OK
```

["Executing `Future`s and Tasks"]: ../02_execution/01_chapter.md
[the `Future` trait]: ../02_execution/02_future.md
